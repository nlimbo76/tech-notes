<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OTA 업데이트 파이프라인과 이미지 서명 (정리판) | gBear's Tech Notes</title><meta name=keywords content="OTA,서명,보안,부트로더,A/B,임베디드"><meta name=description content='개요
현장 장비의 펌웨어 업데이트(OTA)는 가용성·보안·복구성이 핵심입니다. 이 문서는
A/B 슬롯 전략 + 서명/무결성 검증 + 점진적 배포를 축으로 한 엔드투엔드 파이프라인을 정리합니다.
목표는 “중단 없이, 위변조 없이, 실패해도 자동 복구” 입니다.

핵심 개념 / 설계 포인트

서명과 무결성: 이미지 SHA-256 해시 + 서명(Ed25519/ECDSA) + 메타데이터를 번들로 관리.
A/B 파티션: 비활성 슬롯에 다운로드→검증→스위치. 부팅 성공 신호 없으면 자동 롤백.
메타데이터(Manifest): 버전, 타깃(보드/SoC), 빌드 타임, 해시, 최소 부트로더/SE 버전, anti-rollback 카운터.
전송 보안: 서버↔디바이스 TLS/DTLS + 서버 측 토큰/기기 인증. 전송 보안 ≠ 이미지 신뢰.
신뢰 루트: 부트로더에 공개키 고정(ROM/섹션). 키 교체는 롤링 방식(Trust Anchor version).
대상 선정/점진 배포: 롤링 퍼센트(1%→10%→50%→100%), 지역/모델/펌웨어 라인업 기반 타겟팅.
중단 내성: 청크 다운로드 + 재시작 재개 + 이중 버퍼링 + 저널링/원자 스위치.
로깅/관측성: 기기별 업데이트 이력, 실패코드, 롤백 사유, 배포 cohort 성과.


시스템 구성(참고 아키텍처)
Developer → CI(빌드/사인) → Artifact Store(CDN/S3)
             │                ↑
             └─ Backend(메타/대상선정/토큰) ─→ Device(Agent)
                                       ↓
                               Bootloader(Verify/Swap/Rollback)

CI: 펌웨어 빌드, 해시 산출, 오프라인 서명(가능하면 HSM).
Artifact Store: 압축된 펌웨어 + manifest. Range 요청/Resume 지원.
Backend: 대상 선택, 배포 라운드, 토큰 발급, 통계 수집.
Device Agent: 다운로드/검증/스위치 요청/헬스체크 보고.
Bootloader: 유일한 신뢰 판단자. 공개키로 manifest+이미지 검증.


Manifest 포맷(예시, JSON)
{
  "board": "nx3000",
  "soc": "stm32h7",
  "version": "1.4.3",
  "build": "2025-08-20T13:55:21Z",
  "min_boot": 3,
  "anti_rollback": 42,
  "image": {
    "filename": "app_v1.4.3.bin",
    "size": 524288,
    "sha256": "3f5c...ab9d"
  },
  "sign": {
    "alg": "Ed25519",
    "pub_key_id": "k-2025-q3",
    "sig": "base64-encoded-signature"
  }
}

anti_rollback: 부트로더 카운터 >= 값이어야 설치 허용.
pub_key_id: 키 롤오버 시 버전을 구분(구 키 폐기 시점 통제).


서명 파이프라인(오프라인 예시)
# 1) 해시 생성
sha256sum app.bin > app.bin.sha256

# 2) Ed25519 키 생성(오프라인/보안 저장)
openssl genpkey -algorithm Ed25519 -out ed25519_priv.pem
openssl pkey -in ed25519_priv.pem -pubout -out ed25519_pub.pem

# 3) 서명
openssl pkeyutl -sign -inkey ed25519_priv.pem -in app.bin -out app.bin.sig

# 4) 서명 검증(빌드 서버/테스트)
openssl pkeyutl -verify -pubin -inkey ed25519_pub.pem -sigfile app.bin.sig -in app.bin

실제 배포에서는 manifest 전체(메타+해시)를 서명하는 방식을 권장.
서명 전용 키는 HSM/YubiKey/전용 키 관리 서버에 보관.'><meta name=author content="gBear"><link rel=canonical href=https://nlimbo76.github.io/tech-notes/posts/ota-signed-pipeline/><link crossorigin=anonymous href=/tech-notes/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://nlimbo76.github.io/tech-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nlimbo76.github.io/tech-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nlimbo76.github.io/tech-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://nlimbo76.github.io/tech-notes/apple-touch-icon.png><link rel=mask-icon href=https://nlimbo76.github.io/tech-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nlimbo76.github.io/tech-notes/posts/ota-signed-pipeline/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://nlimbo76.github.io/tech-notes/posts/ota-signed-pipeline/"><meta property="og:site_name" content="gBear's Tech Notes"><meta property="og:title" content="OTA 업데이트 파이프라인과 이미지 서명 (정리판)"><meta property="og:description" content='개요 현장 장비의 펌웨어 업데이트(OTA)는 가용성·보안·복구성이 핵심입니다. 이 문서는 A/B 슬롯 전략 + 서명/무결성 검증 + 점진적 배포를 축으로 한 엔드투엔드 파이프라인을 정리합니다. 목표는 “중단 없이, 위변조 없이, 실패해도 자동 복구” 입니다.
핵심 개념 / 설계 포인트 서명과 무결성: 이미지 SHA-256 해시 + 서명(Ed25519/ECDSA) + 메타데이터를 번들로 관리. A/B 파티션: 비활성 슬롯에 다운로드→검증→스위치. 부팅 성공 신호 없으면 자동 롤백. 메타데이터(Manifest): 버전, 타깃(보드/SoC), 빌드 타임, 해시, 최소 부트로더/SE 버전, anti-rollback 카운터. 전송 보안: 서버↔디바이스 TLS/DTLS + 서버 측 토큰/기기 인증. 전송 보안 ≠ 이미지 신뢰. 신뢰 루트: 부트로더에 공개키 고정(ROM/섹션). 키 교체는 롤링 방식(Trust Anchor version). 대상 선정/점진 배포: 롤링 퍼센트(1%→10%→50%→100%), 지역/모델/펌웨어 라인업 기반 타겟팅. 중단 내성: 청크 다운로드 + 재시작 재개 + 이중 버퍼링 + 저널링/원자 스위치. 로깅/관측성: 기기별 업데이트 이력, 실패코드, 롤백 사유, 배포 cohort 성과. 시스템 구성(참고 아키텍처) Developer → CI(빌드/사인) → Artifact Store(CDN/S3) │ ↑ └─ Backend(메타/대상선정/토큰) ─→ Device(Agent) ↓ Bootloader(Verify/Swap/Rollback) CI: 펌웨어 빌드, 해시 산출, 오프라인 서명(가능하면 HSM). Artifact Store: 압축된 펌웨어 + manifest. Range 요청/Resume 지원. Backend: 대상 선택, 배포 라운드, 토큰 발급, 통계 수집. Device Agent: 다운로드/검증/스위치 요청/헬스체크 보고. Bootloader: 유일한 신뢰 판단자. 공개키로 manifest+이미지 검증. Manifest 포맷(예시, JSON) { "board": "nx3000", "soc": "stm32h7", "version": "1.4.3", "build": "2025-08-20T13:55:21Z", "min_boot": 3, "anti_rollback": 42, "image": { "filename": "app_v1.4.3.bin", "size": 524288, "sha256": "3f5c...ab9d" }, "sign": { "alg": "Ed25519", "pub_key_id": "k-2025-q3", "sig": "base64-encoded-signature" } } anti_rollback: 부트로더 카운터 >= 값이어야 설치 허용. pub_key_id: 키 롤오버 시 버전을 구분(구 키 폐기 시점 통제). 서명 파이프라인(오프라인 예시) # 1) 해시 생성 sha256sum app.bin > app.bin.sha256 # 2) Ed25519 키 생성(오프라인/보안 저장) openssl genpkey -algorithm Ed25519 -out ed25519_priv.pem openssl pkey -in ed25519_priv.pem -pubout -out ed25519_pub.pem # 3) 서명 openssl pkeyutl -sign -inkey ed25519_priv.pem -in app.bin -out app.bin.sig # 4) 서명 검증(빌드 서버/테스트) openssl pkeyutl -verify -pubin -inkey ed25519_pub.pem -sigfile app.bin.sig -in app.bin 실제 배포에서는 manifest 전체(메타+해시)를 서명하는 방식을 권장. 서명 전용 키는 HSM/YubiKey/전용 키 관리 서버에 보관.'><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-24T00:00:00+00:00"><meta property="article:tag" content="OTA"><meta property="article:tag" content="서명"><meta property="article:tag" content="보안"><meta property="article:tag" content="부트로더"><meta property="article:tag" content="A/B"><meta property="article:tag" content="임베디드"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/delta-ota-storage-layout/"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/bootloader-ab-rollback/"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/safe-mode-recovery/"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/key-rollover-trust-anchor/"><meta name=twitter:card content="summary"><meta name=twitter:title content="OTA 업데이트 파이프라인과 이미지 서명 (정리판)"><meta name=twitter:description content='개요
현장 장비의 펌웨어 업데이트(OTA)는 가용성·보안·복구성이 핵심입니다. 이 문서는
A/B 슬롯 전략 + 서명/무결성 검증 + 점진적 배포를 축으로 한 엔드투엔드 파이프라인을 정리합니다.
목표는 “중단 없이, 위변조 없이, 실패해도 자동 복구” 입니다.

핵심 개념 / 설계 포인트

서명과 무결성: 이미지 SHA-256 해시 + 서명(Ed25519/ECDSA) + 메타데이터를 번들로 관리.
A/B 파티션: 비활성 슬롯에 다운로드→검증→스위치. 부팅 성공 신호 없으면 자동 롤백.
메타데이터(Manifest): 버전, 타깃(보드/SoC), 빌드 타임, 해시, 최소 부트로더/SE 버전, anti-rollback 카운터.
전송 보안: 서버↔디바이스 TLS/DTLS + 서버 측 토큰/기기 인증. 전송 보안 ≠ 이미지 신뢰.
신뢰 루트: 부트로더에 공개키 고정(ROM/섹션). 키 교체는 롤링 방식(Trust Anchor version).
대상 선정/점진 배포: 롤링 퍼센트(1%→10%→50%→100%), 지역/모델/펌웨어 라인업 기반 타겟팅.
중단 내성: 청크 다운로드 + 재시작 재개 + 이중 버퍼링 + 저널링/원자 스위치.
로깅/관측성: 기기별 업데이트 이력, 실패코드, 롤백 사유, 배포 cohort 성과.


시스템 구성(참고 아키텍처)
Developer → CI(빌드/사인) → Artifact Store(CDN/S3)
             │                ↑
             └─ Backend(메타/대상선정/토큰) ─→ Device(Agent)
                                       ↓
                               Bootloader(Verify/Swap/Rollback)

CI: 펌웨어 빌드, 해시 산출, 오프라인 서명(가능하면 HSM).
Artifact Store: 압축된 펌웨어 + manifest. Range 요청/Resume 지원.
Backend: 대상 선택, 배포 라운드, 토큰 발급, 통계 수집.
Device Agent: 다운로드/검증/스위치 요청/헬스체크 보고.
Bootloader: 유일한 신뢰 판단자. 공개키로 manifest+이미지 검증.


Manifest 포맷(예시, JSON)
{
  "board": "nx3000",
  "soc": "stm32h7",
  "version": "1.4.3",
  "build": "2025-08-20T13:55:21Z",
  "min_boot": 3,
  "anti_rollback": 42,
  "image": {
    "filename": "app_v1.4.3.bin",
    "size": 524288,
    "sha256": "3f5c...ab9d"
  },
  "sign": {
    "alg": "Ed25519",
    "pub_key_id": "k-2025-q3",
    "sig": "base64-encoded-signature"
  }
}

anti_rollback: 부트로더 카운터 >= 값이어야 설치 허용.
pub_key_id: 키 롤오버 시 버전을 구분(구 키 폐기 시점 통제).


서명 파이프라인(오프라인 예시)
# 1) 해시 생성
sha256sum app.bin > app.bin.sha256

# 2) Ed25519 키 생성(오프라인/보안 저장)
openssl genpkey -algorithm Ed25519 -out ed25519_priv.pem
openssl pkey -in ed25519_priv.pem -pubout -out ed25519_pub.pem

# 3) 서명
openssl pkeyutl -sign -inkey ed25519_priv.pem -in app.bin -out app.bin.sig

# 4) 서명 검증(빌드 서버/테스트)
openssl pkeyutl -verify -pubin -inkey ed25519_pub.pem -sigfile app.bin.sig -in app.bin

실제 배포에서는 manifest 전체(메타+해시)를 서명하는 방식을 권장.
서명 전용 키는 HSM/YubiKey/전용 키 관리 서버에 보관.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nlimbo76.github.io/tech-notes/posts/"},{"@type":"ListItem","position":2,"name":"OTA 업데이트 파이프라인과 이미지 서명 (정리판)","item":"https://nlimbo76.github.io/tech-notes/posts/ota-signed-pipeline/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OTA 업데이트 파이프라인과 이미지 서명 (정리판)","name":"OTA 업데이트 파이프라인과 이미지 서명 (정리판)","description":"개요 현장 장비의 펌웨어 업데이트(OTA)는 가용성·보안·복구성이 핵심입니다. 이 문서는 A/B 슬롯 전략 + 서명/무결성 검증 + 점진적 배포를 축으로 한 엔드투엔드 파이프라인을 정리합니다. 목표는 “중단 없이, 위변조 없이, 실패해도 자동 복구” 입니다.\n핵심 개념 / 설계 포인트 서명과 무결성: 이미지 SHA-256 해시 + 서명(Ed25519/ECDSA) + 메타데이터를 번들로 관리. A/B 파티션: 비활성 슬롯에 다운로드→검증→스위치. 부팅 성공 신호 없으면 자동 롤백. 메타데이터(Manifest): 버전, 타깃(보드/SoC), 빌드 타임, 해시, 최소 부트로더/SE 버전, anti-rollback 카운터. 전송 보안: 서버↔디바이스 TLS/DTLS + 서버 측 토큰/기기 인증. 전송 보안 ≠ 이미지 신뢰. 신뢰 루트: 부트로더에 공개키 고정(ROM/섹션). 키 교체는 롤링 방식(Trust Anchor version). 대상 선정/점진 배포: 롤링 퍼센트(1%→10%→50%→100%), 지역/모델/펌웨어 라인업 기반 타겟팅. 중단 내성: 청크 다운로드 + 재시작 재개 + 이중 버퍼링 + 저널링/원자 스위치. 로깅/관측성: 기기별 업데이트 이력, 실패코드, 롤백 사유, 배포 cohort 성과. 시스템 구성(참고 아키텍처) Developer → CI(빌드/사인) → Artifact Store(CDN/S3) │ ↑ └─ Backend(메타/대상선정/토큰) ─→ Device(Agent) ↓ Bootloader(Verify/Swap/Rollback) CI: 펌웨어 빌드, 해시 산출, 오프라인 서명(가능하면 HSM). Artifact Store: 압축된 펌웨어 + manifest. Range 요청/Resume 지원. Backend: 대상 선택, 배포 라운드, 토큰 발급, 통계 수집. Device Agent: 다운로드/검증/스위치 요청/헬스체크 보고. Bootloader: 유일한 신뢰 판단자. 공개키로 manifest+이미지 검증. Manifest 포맷(예시, JSON) { \u0026#34;board\u0026#34;: \u0026#34;nx3000\u0026#34;, \u0026#34;soc\u0026#34;: \u0026#34;stm32h7\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.4.3\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;2025-08-20T13:55:21Z\u0026#34;, \u0026#34;min_boot\u0026#34;: 3, \u0026#34;anti_rollback\u0026#34;: 42, \u0026#34;image\u0026#34;: { \u0026#34;filename\u0026#34;: \u0026#34;app_v1.4.3.bin\u0026#34;, \u0026#34;size\u0026#34;: 524288, \u0026#34;sha256\u0026#34;: \u0026#34;3f5c...ab9d\u0026#34; }, \u0026#34;sign\u0026#34;: { \u0026#34;alg\u0026#34;: \u0026#34;Ed25519\u0026#34;, \u0026#34;pub_key_id\u0026#34;: \u0026#34;k-2025-q3\u0026#34;, \u0026#34;sig\u0026#34;: \u0026#34;base64-encoded-signature\u0026#34; } } anti_rollback: 부트로더 카운터 \u0026gt;= 값이어야 설치 허용. pub_key_id: 키 롤오버 시 버전을 구분(구 키 폐기 시점 통제). 서명 파이프라인(오프라인 예시) # 1) 해시 생성 sha256sum app.bin \u0026gt; app.bin.sha256 # 2) Ed25519 키 생성(오프라인/보안 저장) openssl genpkey -algorithm Ed25519 -out ed25519_priv.pem openssl pkey -in ed25519_priv.pem -pubout -out ed25519_pub.pem # 3) 서명 openssl pkeyutl -sign -inkey ed25519_priv.pem -in app.bin -out app.bin.sig # 4) 서명 검증(빌드 서버/테스트) openssl pkeyutl -verify -pubin -inkey ed25519_pub.pem -sigfile app.bin.sig -in app.bin 실제 배포에서는 manifest 전체(메타+해시)를 서명하는 방식을 권장. 서명 전용 키는 HSM/YubiKey/전용 키 관리 서버에 보관.\n","keywords":["OTA","서명","보안","부트로더","A/B","임베디드"],"articleBody":"개요 현장 장비의 펌웨어 업데이트(OTA)는 가용성·보안·복구성이 핵심입니다. 이 문서는 A/B 슬롯 전략 + 서명/무결성 검증 + 점진적 배포를 축으로 한 엔드투엔드 파이프라인을 정리합니다. 목표는 “중단 없이, 위변조 없이, 실패해도 자동 복구” 입니다.\n핵심 개념 / 설계 포인트 서명과 무결성: 이미지 SHA-256 해시 + 서명(Ed25519/ECDSA) + 메타데이터를 번들로 관리. A/B 파티션: 비활성 슬롯에 다운로드→검증→스위치. 부팅 성공 신호 없으면 자동 롤백. 메타데이터(Manifest): 버전, 타깃(보드/SoC), 빌드 타임, 해시, 최소 부트로더/SE 버전, anti-rollback 카운터. 전송 보안: 서버↔디바이스 TLS/DTLS + 서버 측 토큰/기기 인증. 전송 보안 ≠ 이미지 신뢰. 신뢰 루트: 부트로더에 공개키 고정(ROM/섹션). 키 교체는 롤링 방식(Trust Anchor version). 대상 선정/점진 배포: 롤링 퍼센트(1%→10%→50%→100%), 지역/모델/펌웨어 라인업 기반 타겟팅. 중단 내성: 청크 다운로드 + 재시작 재개 + 이중 버퍼링 + 저널링/원자 스위치. 로깅/관측성: 기기별 업데이트 이력, 실패코드, 롤백 사유, 배포 cohort 성과. 시스템 구성(참고 아키텍처) Developer → CI(빌드/사인) → Artifact Store(CDN/S3) │ ↑ └─ Backend(메타/대상선정/토큰) ─→ Device(Agent) ↓ Bootloader(Verify/Swap/Rollback) CI: 펌웨어 빌드, 해시 산출, 오프라인 서명(가능하면 HSM). Artifact Store: 압축된 펌웨어 + manifest. Range 요청/Resume 지원. Backend: 대상 선택, 배포 라운드, 토큰 발급, 통계 수집. Device Agent: 다운로드/검증/스위치 요청/헬스체크 보고. Bootloader: 유일한 신뢰 판단자. 공개키로 manifest+이미지 검증. Manifest 포맷(예시, JSON) { \"board\": \"nx3000\", \"soc\": \"stm32h7\", \"version\": \"1.4.3\", \"build\": \"2025-08-20T13:55:21Z\", \"min_boot\": 3, \"anti_rollback\": 42, \"image\": { \"filename\": \"app_v1.4.3.bin\", \"size\": 524288, \"sha256\": \"3f5c...ab9d\" }, \"sign\": { \"alg\": \"Ed25519\", \"pub_key_id\": \"k-2025-q3\", \"sig\": \"base64-encoded-signature\" } } anti_rollback: 부트로더 카운터 \u003e= 값이어야 설치 허용. pub_key_id: 키 롤오버 시 버전을 구분(구 키 폐기 시점 통제). 서명 파이프라인(오프라인 예시) # 1) 해시 생성 sha256sum app.bin \u003e app.bin.sha256 # 2) Ed25519 키 생성(오프라인/보안 저장) openssl genpkey -algorithm Ed25519 -out ed25519_priv.pem openssl pkey -in ed25519_priv.pem -pubout -out ed25519_pub.pem # 3) 서명 openssl pkeyutl -sign -inkey ed25519_priv.pem -in app.bin -out app.bin.sig # 4) 서명 검증(빌드 서버/테스트) openssl pkeyutl -verify -pubin -inkey ed25519_pub.pem -sigfile app.bin.sig -in app.bin 실제 배포에서는 manifest 전체(메타+해시)를 서명하는 방식을 권장. 서명 전용 키는 HSM/YubiKey/전용 키 관리 서버에 보관.\n부트로더 검증(의사코드) bool verify_image(const manifest_t* m, const uint8_t* img, size_t img_len) { if (!version_ok(m-\u003emin_boot) || anti_rollback_counter() \u003c m-\u003eanti_rollback) return false; uint8_t h[32]; sha256(img, img_len, h); if (memcmp(h, m-\u003eimage.sha256, 32) != 0) return false; if (!ed25519_verify(m-\u003esign.sig, (uint8_t*)m, manifest_signed_len(m), m-\u003esign.pub_key_id)) return false; return true; } ed25519_verify(...): 펌웨어에 포함된 공개키 테이블 또는 신뢰 앵커에서 pub_key_id에 해당하는 키 사용. manifest_signed_len(m): 서명 대상 구간(manifest에서 sig 필드 제외). A/B + 롤백(요지) 비활성 슬롯(B)에 다운로드 → verify_image. 부팅 대상 전환: boot_slot=B, trial=1, attempts=3 등 설정. 새 앱이 정해진 시간 내 health_ok 보고 → trial=0 → 확정. 미보고/크래시 시 attempts 0이 되면 자동 롤백. 헬스 시그널은 부트로더가 읽을 수 있는 단일 플래그로, 전원 중단에도 안전해야 합니다.\n전송·저장 중단 내성 청크 다운로드/재개: Range: bytes= + 체크섬(블록 단위). 저널링/더블버퍼: manifest/이미지 쓰기 시 원자 갱신 보장. 압축/델타 업데이트: 전체 이미지 대신 bsdiff/zstd 델타(부트로더가 델타 지원하면 가장 이상적). 백엔드: 대상선정 · 배포전략 코호트: 기기 라벨링(모델/지역/펌웨어 채널). 트래픽 제어: 백오프/레이트 제한 + 분산 시작시간. 모니터링: 성공률, 롤백률, 평균 소요시간, 실패 원인 코드(서명/해시/네트워크/스토리지). Threat Model(간략) 전송 중 공격: TLS/DTLS, 토큰/클라이언트 인증으로 완화. (그래도 이미지 자체 서명 검증 필수) 저장 중 위변조: 해시/서명 + anti-rollback(카운터/버전 퓨즈). 키 탈취: 오프라인 서명, 키 롤오버, 다중 담당자 승인(4-eyes), 서명 환경 격리. Downgrade 공격: anti-rollback과 채널 정책(Stable/Beta 분리). 실무 가이드 (체크리스트 중심) Manifest 전체에 서명(메타+이미지 해시 포함). 공개키 신뢰루트를 부트로더에 내장, 키 롤오버 전략 포함. anti-rollback 카운터/버전 퓨즈 도입. 비활성 슬롯(B)에 검증 후 스위치(원자성 보장). 헬스체크/타임박스와 자동 롤백 경로. 청크 다운로드/Resume + 블록 체크섬. 배포는 점진 롤아웃 + 코호트 관리 + 관측성. 실패 로그/원인 코드를 서버로 수집(서명/해시/스토리지/네트워크 구분). 트러블슈팅 빠른 표 증상 의심 포인트 조치 부트 후 즉시 롤백 헬스체크 미신호/타임아웃, attempts 정책 과严 앱 초기화 순서 단축·헬스신호 시점 조정 설치는 되나 부팅 실패 anti-rollback/키 ID/manifest 불일치 빌드/배포 파이프라인의 키/버전 싱크 체크 일부 지역만 실패 CDN/레인지 요청/프록시 이슈 블록 크기/타임아웃 튜닝, 재시도/백오프 간헐적 손상 전원 중단/플래시 wear-level 저널링/원자 쓰기, 배터리 상태 기반 업데이트 연계 글 (예정) “부트로더 Safe Mode + 리커버리 설계” “델타 OTA와 스토리지 레이아웃(분할/정렬/Wear-level)” “키 롤오버와 신뢰 앵커 마이그레이션” ","wordCount":"628","inLanguage":"en","datePublished":"2025-08-24T00:00:00Z","dateModified":"2025-08-24T00:00:00Z","author":{"@type":"Person","name":"gBear"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nlimbo76.github.io/tech-notes/posts/ota-signed-pipeline/"},"publisher":{"@type":"Organization","name":"gBear's Tech Notes","logo":{"@type":"ImageObject","url":"https://nlimbo76.github.io/tech-notes/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nlimbo76.github.io/tech-notes/ accesskey=h title="gBear's Tech Notes (Alt + H)">gBear's Tech Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nlimbo76.github.io/tech-notes/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://nlimbo76.github.io/tech-notes/series/ title=Series><span>Series</span></a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://nlimbo76.github.io/tech-notes/>Home</a>&nbsp;»&nbsp;<a href=https://nlimbo76.github.io/tech-notes/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">OTA 업데이트 파이프라인과 이미지 서명 (정리판)</h1><div class=post-meta><span title='2025-08-24 00:00:00 +0000 UTC'>2025-08-24</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;gBear</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b0%9c%ec%9a%94 aria-label=개요>개요</a></li><li><a href=#%ed%95%b5%ec%8b%ac-%ea%b0%9c%eb%85%90--%ec%84%a4%ea%b3%84-%ed%8f%ac%ec%9d%b8%ed%8a%b8 aria-label="핵심 개념 / 설계 포인트">핵심 개념 / 설계 포인트</a></li><li><a href=#%ec%8b%9c%ec%8a%a4%ed%85%9c-%ea%b5%ac%ec%84%b1%ec%b0%b8%ea%b3%a0-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98 aria-label="시스템 구성(참고 아키텍처)">시스템 구성(참고 아키텍처)</a></li><li><a href=#manifest-%ed%8f%ac%eb%a7%b7%ec%98%88%ec%8b%9c-json aria-label="Manifest 포맷(예시, JSON)">Manifest 포맷(예시, JSON)</a></li><li><a href=#%ec%84%9c%eb%aa%85-%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8%ec%98%a4%ed%94%84%eb%9d%bc%ec%9d%b8-%ec%98%88%ec%8b%9c aria-label="서명 파이프라인(오프라인 예시)">서명 파이프라인(오프라인 예시)</a></li><li><a href=#%eb%b6%80%ed%8a%b8%eb%a1%9c%eb%8d%94-%ea%b2%80%ec%a6%9d%ec%9d%98%ec%82%ac%ec%bd%94%eb%93%9c aria-label="부트로더 검증(의사코드)">부트로더 검증(의사코드)</a></li><li><a href=#ab--%eb%a1%a4%eb%b0%b1%ec%9a%94%ec%a7%80 aria-label="A/B + 롤백(요지)">A/B + 롤백(요지)</a></li><li><a href=#%ec%a0%84%ec%86%a1%ec%a0%80%ec%9e%a5-%ec%a4%91%eb%8b%a8-%eb%82%b4%ec%84%b1 aria-label="전송·저장 중단 내성">전송·저장 중단 내성</a></li><li><a href=#%eb%b0%b1%ec%97%94%eb%93%9c-%eb%8c%80%ec%83%81%ec%84%a0%ec%a0%95--%eb%b0%b0%ed%8f%ac%ec%a0%84%eb%9e%b5 aria-label="백엔드: 대상선정 · 배포전략">백엔드: 대상선정 · 배포전략</a></li><li><a href=#threat-model%ea%b0%84%eb%9e%b5 aria-label="Threat Model(간략)">Threat Model(간략)</a></li><li><a href=#%ec%8b%a4%eb%ac%b4-%ea%b0%80%ec%9d%b4%eb%93%9c-%ec%b2%b4%ed%81%ac%eb%a6%ac%ec%8a%a4%ed%8a%b8-%ec%a4%91%ec%8b%ac aria-label="실무 가이드 (체크리스트 중심)">실무 가이드 (체크리스트 중심)</a></li><li><a href=#%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85-%eb%b9%a0%eb%a5%b8-%ed%91%9c aria-label="트러블슈팅 빠른 표">트러블슈팅 빠른 표</a></li><li><a href=#%ec%97%b0%ea%b3%84-%ea%b8%80-%ec%98%88%ec%a0%95 aria-label="연계 글 (예정)">연계 글 (예정)</a></li></ul></div></details></div><div class=post-content><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><p>현장 장비의 펌웨어 업데이트(OTA)는 <strong>가용성·보안·복구성</strong>이 핵심입니다. 이 문서는
<strong>A/B 슬롯 전략 + 서명/무결성 검증 + 점진적 배포</strong>를 축으로 한 <strong>엔드투엔드 파이프라인</strong>을 정리합니다.
목표는 <em>“중단 없이, 위변조 없이, 실패해도 자동 복구”</em> 입니다.</p><hr><h2 id=핵심-개념--설계-포인트>핵심 개념 / 설계 포인트<a hidden class=anchor aria-hidden=true href=#핵심-개념--설계-포인트>#</a></h2><ul><li><strong>서명과 무결성</strong>: 이미지 <code>SHA-256 해시</code> + <code>서명(Ed25519/ECDSA)</code> + <code>메타데이터</code>를 <strong>번들</strong>로 관리.</li><li><strong>A/B 파티션</strong>: 비활성 슬롯에 다운로드→검증→스위치. 부팅 성공 신호 없으면 <strong>자동 롤백</strong>.</li><li><strong>메타데이터(Manifest)</strong>: 버전, 타깃(보드/SoC), 빌드 타임, 해시, 최소 부트로더/SE 버전, <strong>anti-rollback 카운터</strong>.</li><li><strong>전송 보안</strong>: 서버↔디바이스 <strong>TLS/DTLS</strong> + 서버 측 <strong>토큰/기기 인증</strong>. 전송 보안 ≠ 이미지 신뢰.</li><li><strong>신뢰 루트</strong>: 부트로더에 <strong>공개키 고정</strong>(ROM/섹션). 키 교체는 롤링 방식(Trust Anchor version).</li><li><strong>대상 선정/점진 배포</strong>: 롤링 퍼센트(1%→10%→50%→100%), 지역/모델/펌웨어 라인업 기반 타겟팅.</li><li><strong>중단 내성</strong>: 청크 다운로드 + 재시작 재개 + 이중 버퍼링 + 저널링/원자 스위치.</li><li><strong>로깅/관측성</strong>: 기기별 업데이트 이력, 실패코드, 롤백 사유, 배포 cohort 성과.</li></ul><hr><h2 id=시스템-구성참고-아키텍처>시스템 구성(참고 아키텍처)<a hidden class=anchor aria-hidden=true href=#시스템-구성참고-아키텍처>#</a></h2><pre tabindex=0><code>Developer → CI(빌드/사인) → Artifact Store(CDN/S3)
             │                ↑
             └─ Backend(메타/대상선정/토큰) ─→ Device(Agent)
                                       ↓
                               Bootloader(Verify/Swap/Rollback)
</code></pre><ul><li><strong>CI</strong>: 펌웨어 빌드, 해시 산출, <strong>오프라인 서명</strong>(가능하면 HSM).</li><li><strong>Artifact Store</strong>: 압축된 펌웨어 + manifest. Range 요청/Resume 지원.</li><li><strong>Backend</strong>: 대상 선택, 배포 라운드, 토큰 발급, 통계 수집.</li><li><strong>Device Agent</strong>: 다운로드/검증/스위치 요청/헬스체크 보고.</li><li><strong>Bootloader</strong>: <strong>유일한 신뢰 판단자</strong>. 공개키로 manifest+이미지 검증.</li></ul><hr><h2 id=manifest-포맷예시-json>Manifest 포맷(예시, JSON)<a hidden class=anchor aria-hidden=true href=#manifest-포맷예시-json>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;board&#34;</span><span class=p>:</span> <span class=s2>&#34;nx3000&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;soc&#34;</span><span class=p>:</span> <span class=s2>&#34;stm32h7&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;version&#34;</span><span class=p>:</span> <span class=s2>&#34;1.4.3&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;build&#34;</span><span class=p>:</span> <span class=s2>&#34;2025-08-20T13:55:21Z&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;min_boot&#34;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;anti_rollback&#34;</span><span class=p>:</span> <span class=mi>42</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;image&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;filename&#34;</span><span class=p>:</span> <span class=s2>&#34;app_v1.4.3.bin&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=mi>524288</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;sha256&#34;</span><span class=p>:</span> <span class=s2>&#34;3f5c...ab9d&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;sign&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;alg&#34;</span><span class=p>:</span> <span class=s2>&#34;Ed25519&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;pub_key_id&#34;</span><span class=p>:</span> <span class=s2>&#34;k-2025-q3&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;sig&#34;</span><span class=p>:</span> <span class=s2>&#34;base64-encoded-signature&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><code>anti_rollback</code>: 부트로더 <strong>카운터 >= 값</strong>이어야 설치 허용.</li><li><code>pub_key_id</code>: 키 롤오버 시 버전을 구분(구 키 폐기 시점 통제).</li></ul><hr><h2 id=서명-파이프라인오프라인-예시>서명 파이프라인(오프라인 예시)<a hidden class=anchor aria-hidden=true href=#서명-파이프라인오프라인-예시>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1) 해시 생성</span>
</span></span><span class=line><span class=cl>sha256sum app.bin &gt; app.bin.sha256
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2) Ed25519 키 생성(오프라인/보안 저장)</span>
</span></span><span class=line><span class=cl>openssl genpkey -algorithm Ed25519 -out ed25519_priv.pem
</span></span><span class=line><span class=cl>openssl pkey -in ed25519_priv.pem -pubout -out ed25519_pub.pem
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3) 서명</span>
</span></span><span class=line><span class=cl>openssl pkeyutl -sign -inkey ed25519_priv.pem -in app.bin -out app.bin.sig
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4) 서명 검증(빌드 서버/테스트)</span>
</span></span><span class=line><span class=cl>openssl pkeyutl -verify -pubin -inkey ed25519_pub.pem -sigfile app.bin.sig -in app.bin
</span></span></code></pre></div><blockquote><p>실제 배포에서는 <strong>manifest 전체</strong>(메타+해시)를 서명하는 방식을 권장.
서명 전용 키는 HSM/YubiKey/전용 키 관리 서버에 보관.</p></blockquote><hr><h2 id=부트로더-검증의사코드>부트로더 검증(의사코드)<a hidden class=anchor aria-hidden=true href=#부트로더-검증의사코드>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>verify_image</span><span class=p>(</span><span class=k>const</span> <span class=kt>manifest_t</span><span class=o>*</span> <span class=n>m</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>img</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>img_len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>version_ok</span><span class=p>(</span><span class=n>m</span><span class=o>-&gt;</span><span class=n>min_boot</span><span class=p>)</span> <span class=o>||</span> <span class=nf>anti_rollback_counter</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>m</span><span class=o>-&gt;</span><span class=n>anti_rollback</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>h</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span> <span class=nf>sha256</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>img_len</span><span class=p>,</span> <span class=n>h</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>memcmp</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>m</span><span class=o>-&gt;</span><span class=n>image</span><span class=p>.</span><span class=n>sha256</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>ed25519_verify</span><span class=p>(</span><span class=n>m</span><span class=o>-&gt;</span><span class=n>sign</span><span class=p>.</span><span class=n>sig</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span><span class=n>m</span><span class=p>,</span> <span class=nf>manifest_signed_len</span><span class=p>(</span><span class=n>m</span><span class=p>),</span> <span class=n>m</span><span class=o>-&gt;</span><span class=n>sign</span><span class=p>.</span><span class=n>pub_key_id</span><span class=p>))</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><code>ed25519_verify(...)</code>: 펌웨어에 포함된 <strong>공개키 테이블</strong> 또는 <strong>신뢰 앵커</strong>에서 <code>pub_key_id</code>에 해당하는 키 사용.</li><li><code>manifest_signed_len(m)</code>: <strong>서명 대상 구간</strong>(manifest에서 <code>sig</code> 필드 제외).</li></ul><hr><h2 id=ab--롤백요지>A/B + 롤백(요지)<a hidden class=anchor aria-hidden=true href=#ab--롤백요지>#</a></h2><ol><li><strong>비활성 슬롯</strong>(B)에 다운로드 → <strong>verify_image</strong>.</li><li>부팅 대상 전환: <code>boot_slot=B</code>, <code>trial=1</code>, <code>attempts=3</code> 등 설정.</li><li>새 앱이 정해진 시간 내 <code>health_ok</code> 보고 → <code>trial=0</code> → 확정.
미보고/크래시 시 <code>attempts</code> 0이 되면 <strong>자동 롤백</strong>.</li></ol><p>헬스 시그널은 <strong>부트로더가 읽을 수 있는 단일 플래그</strong>로, 전원 중단에도 안전해야 합니다.</p><hr><h2 id=전송저장-중단-내성>전송·저장 중단 내성<a hidden class=anchor aria-hidden=true href=#전송저장-중단-내성>#</a></h2><ul><li><strong>청크 다운로드/재개</strong>: <code>Range: bytes=</code> + 체크섬(블록 단위).</li><li><strong>저널링/더블버퍼</strong>: manifest/이미지 쓰기 시 <strong>원자 갱신</strong> 보장.</li><li><strong>압축/델타 업데이트</strong>: 전체 이미지 대신 <strong>bsdiff/zstd</strong> 델타(부트로더가 델타 지원하면 가장 이상적).</li></ul><hr><h2 id=백엔드-대상선정--배포전략>백엔드: 대상선정 · 배포전략<a hidden class=anchor aria-hidden=true href=#백엔드-대상선정--배포전략>#</a></h2><ul><li>코호트: <strong>기기 라벨링</strong>(모델/지역/펌웨어 채널).</li><li>트래픽 제어: <strong>백오프/레이트 제한</strong> + 분산 시작시간.</li><li>모니터링: 성공률, 롤백률, 평균 소요시간, 실패 원인 코드(서명/해시/네트워크/스토리지).</li></ul><hr><h2 id=threat-model간략>Threat Model(간략)<a hidden class=anchor aria-hidden=true href=#threat-model간략>#</a></h2><ul><li><strong>전송 중 공격</strong>: TLS/DTLS, 토큰/클라이언트 인증으로 완화. (그래도 이미지 자체 <strong>서명 검증 필수</strong>)</li><li><strong>저장 중 위변조</strong>: 해시/서명 + anti-rollback(카운터/버전 퓨즈).</li><li><strong>키 탈취</strong>: 오프라인 서명, 키 롤오버, 다중 담당자 승인(4-eyes), 서명 환경 격리.</li><li><strong>Downgrade 공격</strong>: anti-rollback과 채널 정책(Stable/Beta 분리).</li></ul><hr><h2 id=실무-가이드-체크리스트-중심>실무 가이드 (체크리스트 중심)<a hidden class=anchor aria-hidden=true href=#실무-가이드-체크리스트-중심>#</a></h2><ul><li><input disabled type=checkbox> <strong>Manifest 전체</strong>에 서명(메타+이미지 해시 포함).</li><li><input disabled type=checkbox> <strong>공개키 신뢰루트</strong>를 부트로더에 내장, 키 롤오버 전략 포함.</li><li><input disabled type=checkbox> <strong>anti-rollback</strong> 카운터/버전 퓨즈 도입.</li><li><input disabled type=checkbox> 비활성 슬롯(B)에 <strong>검증 후 스위치</strong>(원자성 보장).</li><li><input disabled type=checkbox> <strong>헬스체크/타임박스</strong>와 자동 롤백 경로.</li><li><input disabled type=checkbox> 청크 다운로드/Resume + 블록 체크섬.</li><li><input disabled type=checkbox> 배포는 <strong>점진 롤아웃</strong> + 코호트 관리 + 관측성.</li><li><input disabled type=checkbox> 실패 로그/원인 코드를 서버로 수집(서명/해시/스토리지/네트워크 구분).</li></ul><hr><h2 id=트러블슈팅-빠른-표>트러블슈팅 빠른 표<a hidden class=anchor aria-hidden=true href=#트러블슈팅-빠른-표>#</a></h2><table><thead><tr><th>증상</th><th>의심 포인트</th><th>조치</th></tr></thead><tbody><tr><td>부트 후 즉시 롤백</td><td>헬스체크 미신호/타임아웃, <code>attempts</code> 정책 과严</td><td>앱 초기화 순서 단축·헬스신호 시점 조정</td></tr><tr><td>설치는 되나 부팅 실패</td><td>anti-rollback/키 ID/manifest 불일치</td><td>빌드/배포 파이프라인의 키/버전 싱크 체크</td></tr><tr><td>일부 지역만 실패</td><td>CDN/레인지 요청/프록시 이슈</td><td>블록 크기/타임아웃 튜닝, 재시도/백오프</td></tr><tr><td>간헐적 손상</td><td>전원 중단/플래시 wear-level</td><td>저널링/원자 쓰기, 배터리 상태 기반 업데이트</td></tr></tbody></table><hr><h2 id=연계-글-예정>연계 글 (예정)<a hidden class=anchor aria-hidden=true href=#연계-글-예정>#</a></h2><ul><li>“부트로더 Safe Mode + 리커버리 설계”</li><li>“델타 OTA와 스토리지 레이아웃(분할/정렬/Wear-level)”</li><li>“키 롤오버와 신뢰 앵커 마이그레이션”</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://nlimbo76.github.io/tech-notes/tags/ota/>OTA</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/%EC%84%9C%EB%AA%85/>서명</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/%EB%B3%B4%EC%95%88/>보안</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/%EB%B6%80%ED%8A%B8%EB%A1%9C%EB%8D%94/>부트로더</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/a/b/>A/B</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/>임베디드</a></li></ul><nav class=paginav><a class=prev href=https://nlimbo76.github.io/tech-notes/posts/iot-binary-size-optimization/><span class=title>« Prev</span><br><span>IoT 타깃 소형화 전략: 바이너리·메모리 최적화 체크리스트</span>
</a><a class=next href=https://nlimbo76.github.io/tech-notes/posts/delta-ota-storage-layout/><span class=title>Next »</span><br><span>델타 OTA와 스토리지 레이아웃 (분할/정렬/Wear-level) (정리판)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://nlimbo76.github.io/tech-notes/>gBear's Tech Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>