<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>델타 OTA와 스토리지 레이아웃 (분할/정렬/Wear-level) (정리판) | gBear's Tech Notes</title><meta name=keywords content="OTA,델타업데이트,스토리지,Wear-level,링커/레이아웃"><meta name=description content='개요
네트워크/스토리지 제약이 큰 디바이스에서는 델타 OTA(이전 버전 대비 차분만 전송)가 큰 이점을 줍니다. 하지만 플래시 정렬/지우기 단위, 전원 중단 내성, Wear-level, 베이스 버전 검증 등 레이아웃 제약을 함께 설계해야 합니다.

핵심 포인트

델타 형식: bsdiff/xdelta/압축 결합(zstd). MCU에선 스트리밍 적용 가능한 간단 포맷 선호.
베이스 버전 고정: from_version과 베이스 해시를 manifest에 명시, 불일치 시 전체 이미지로 폴백.
Out-of-place 적용: 같은 슬롯 내 임시 영역 또는 B슬롯에 패치 적용 후 스왑(권장).
정렬/지우기 단위: NOR(4–64KB), NAND(128KB+) 지우기 단위에 맞춰 청크 경계/쓰기 정렬 유지.
검증: 적용 후 전체 해시 재검증 + 블록 CRC. 전원 끊김 시 재개 지점 기록.
Wear-level: 자주 바뀌는 메타/로그는 순환 영역 사용, 델타 임시 파일은 균등 분산.


레이아웃 예시
[Boot] [Env] [A: App] [B: App] [DeltaScratch] [Shared(Log/Meta)]

DeltaScratch: 패치 적용 중 임시 저장, 지우기 단위 정렬.
Shared: 오류 로그/통계, 롤백 후 원인 분석에 활용.


델타 적용 흐름(의사코드)
bool apply_delta(const patch_t* p){
  if (!base_version_ok(p->from_ver) || !base_hash_ok(p->from_hash)) return false;
  pos = 0;
  while (next_chunk(&amp;chunk)){
    if (!verify_chunk_crc(&amp;chunk)) return fail_resume(pos);
    write_aligned(dst, chunk.data, chunk.len);   // erase-before-write + align
    pos += chunk.len;
    store_resume_marker(pos);
  }
  return verify_full_hash(dst, p->target_hash);
}

재개 마커: 전원 실패 후 pos부터 재시작. 마커는 저널 방식/2섹터 토글.


Manifest(추가 필드 예시)
{{
  "from_version": "1.4.2",
  "from_hash": "base-image-sha256",
  "target_version": "1.4.3",
  "target_hash": "new-image-sha256",
  "delta_size": 183742,
  "block": 65536,
  "apply": {{
    "erase_align": 65536,
    "write_align": 256
  }}
}}

erase_align/write_align은 디바이스별로 다르므로 서버가 타깃별 manifest를 생성.


성능/신뢰성 팁

작은 패치는 압축 이득 < 오버헤드일 수 있음 → 임계값 이상에서만 델타 사용.
대용량 NAND는 ECC/OOB 고려, 블록 불량 테이블(BBT) 유지.
측정 자동화: 네트워크 트래픽, 플래시 쓰기량, 적용시간, 실패율을 CI에 리포팅.


체크리스트

 from_version/hash 불일치 시 전체 이미지 폴백.
 Out-of-place 적용 + 스왑(안전).
 정렬/지우기 단위에 맞춘 청크/쓰기.
 재개 마커/블록 CRC + 전체 해시 재검증.
 Wear-level 정책(순환/분산) 적용.
 성능 임계값 기준으로 델타/풀이미지 선택.


흔한 문제

  
      
          현상
          원인
          대응
      
  
  
      
          적용 중 손상
          정렬 미스, 전원 중단
          정렬 강제, 재개 마커 + 저널링
      
      
          부팅 후 크래시
          베이스 mismatch
          베이스 검증 실패 시 폴백 강제
      
      
          플래시 수명 악화
          임시 영역 남용
          임시 영역 wear-level/크기 조정
      
  
'><meta name=author content="gBear"><link rel=canonical href=https://nlimbo76.github.io/tech-notes/posts/delta-ota-storage-layout/><link crossorigin=anonymous href=/tech-notes/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://nlimbo76.github.io/tech-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nlimbo76.github.io/tech-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nlimbo76.github.io/tech-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://nlimbo76.github.io/tech-notes/apple-touch-icon.png><link rel=mask-icon href=https://nlimbo76.github.io/tech-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nlimbo76.github.io/tech-notes/posts/delta-ota-storage-layout/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://nlimbo76.github.io/tech-notes/posts/delta-ota-storage-layout/"><meta property="og:site_name" content="gBear's Tech Notes"><meta property="og:title" content="델타 OTA와 스토리지 레이아웃 (분할/정렬/Wear-level) (정리판)"><meta property="og:description" content='개요 네트워크/스토리지 제약이 큰 디바이스에서는 델타 OTA(이전 버전 대비 차분만 전송)가 큰 이점을 줍니다. 하지만 플래시 정렬/지우기 단위, 전원 중단 내성, Wear-level, 베이스 버전 검증 등 레이아웃 제약을 함께 설계해야 합니다.
핵심 포인트 델타 형식: bsdiff/xdelta/압축 결합(zstd). MCU에선 스트리밍 적용 가능한 간단 포맷 선호. 베이스 버전 고정: from_version과 베이스 해시를 manifest에 명시, 불일치 시 전체 이미지로 폴백. Out-of-place 적용: 같은 슬롯 내 임시 영역 또는 B슬롯에 패치 적용 후 스왑(권장). 정렬/지우기 단위: NOR(4–64KB), NAND(128KB+) 지우기 단위에 맞춰 청크 경계/쓰기 정렬 유지. 검증: 적용 후 전체 해시 재검증 + 블록 CRC. 전원 끊김 시 재개 지점 기록. Wear-level: 자주 바뀌는 메타/로그는 순환 영역 사용, 델타 임시 파일은 균등 분산. 레이아웃 예시 [Boot] [Env] [A: App] [B: App] [DeltaScratch] [Shared(Log/Meta)] DeltaScratch: 패치 적용 중 임시 저장, 지우기 단위 정렬. Shared: 오류 로그/통계, 롤백 후 원인 분석에 활용. 델타 적용 흐름(의사코드) bool apply_delta(const patch_t* p){ if (!base_version_ok(p->from_ver) || !base_hash_ok(p->from_hash)) return false; pos = 0; while (next_chunk(&amp;chunk)){ if (!verify_chunk_crc(&amp;chunk)) return fail_resume(pos); write_aligned(dst, chunk.data, chunk.len); // erase-before-write + align pos += chunk.len; store_resume_marker(pos); } return verify_full_hash(dst, p->target_hash); } 재개 마커: 전원 실패 후 pos부터 재시작. 마커는 저널 방식/2섹터 토글. Manifest(추가 필드 예시) {{ "from_version": "1.4.2", "from_hash": "base-image-sha256", "target_version": "1.4.3", "target_hash": "new-image-sha256", "delta_size": 183742, "block": 65536, "apply": {{ "erase_align": 65536, "write_align": 256 }} }} erase_align/write_align은 디바이스별로 다르므로 서버가 타깃별 manifest를 생성. 성능/신뢰성 팁 작은 패치는 압축 이득 < 오버헤드일 수 있음 → 임계값 이상에서만 델타 사용. 대용량 NAND는 ECC/OOB 고려, 블록 불량 테이블(BBT) 유지. 측정 자동화: 네트워크 트래픽, 플래시 쓰기량, 적용시간, 실패율을 CI에 리포팅. 체크리스트 from_version/hash 불일치 시 전체 이미지 폴백. Out-of-place 적용 + 스왑(안전). 정렬/지우기 단위에 맞춘 청크/쓰기. 재개 마커/블록 CRC + 전체 해시 재검증. Wear-level 정책(순환/분산) 적용. 성능 임계값 기준으로 델타/풀이미지 선택. 흔한 문제 현상 원인 대응 적용 중 손상 정렬 미스, 전원 중단 정렬 강제, 재개 마커 + 저널링 부팅 후 크래시 베이스 mismatch 베이스 검증 실패 시 폴백 강제 플래시 수명 악화 임시 영역 남용 임시 영역 wear-level/크기 조정 '><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-24T00:00:00+00:00"><meta property="article:tag" content="OTA"><meta property="article:tag" content="델타업데이트"><meta property="article:tag" content="스토리지"><meta property="article:tag" content="Wear-Level"><meta property="article:tag" content="링커/레이아웃"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/ota-signed-pipeline/"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/bootloader-ab-rollback/"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/safe-mode-recovery/"><meta property="og:see_also" content="https://nlimbo76.github.io/tech-notes/posts/key-rollover-trust-anchor/"><meta name=twitter:card content="summary"><meta name=twitter:title content="델타 OTA와 스토리지 레이아웃 (분할/정렬/Wear-level) (정리판)"><meta name=twitter:description content='개요
네트워크/스토리지 제약이 큰 디바이스에서는 델타 OTA(이전 버전 대비 차분만 전송)가 큰 이점을 줍니다. 하지만 플래시 정렬/지우기 단위, 전원 중단 내성, Wear-level, 베이스 버전 검증 등 레이아웃 제약을 함께 설계해야 합니다.

핵심 포인트

델타 형식: bsdiff/xdelta/압축 결합(zstd). MCU에선 스트리밍 적용 가능한 간단 포맷 선호.
베이스 버전 고정: from_version과 베이스 해시를 manifest에 명시, 불일치 시 전체 이미지로 폴백.
Out-of-place 적용: 같은 슬롯 내 임시 영역 또는 B슬롯에 패치 적용 후 스왑(권장).
정렬/지우기 단위: NOR(4–64KB), NAND(128KB+) 지우기 단위에 맞춰 청크 경계/쓰기 정렬 유지.
검증: 적용 후 전체 해시 재검증 + 블록 CRC. 전원 끊김 시 재개 지점 기록.
Wear-level: 자주 바뀌는 메타/로그는 순환 영역 사용, 델타 임시 파일은 균등 분산.


레이아웃 예시
[Boot] [Env] [A: App] [B: App] [DeltaScratch] [Shared(Log/Meta)]

DeltaScratch: 패치 적용 중 임시 저장, 지우기 단위 정렬.
Shared: 오류 로그/통계, 롤백 후 원인 분석에 활용.


델타 적용 흐름(의사코드)
bool apply_delta(const patch_t* p){
  if (!base_version_ok(p->from_ver) || !base_hash_ok(p->from_hash)) return false;
  pos = 0;
  while (next_chunk(&amp;chunk)){
    if (!verify_chunk_crc(&amp;chunk)) return fail_resume(pos);
    write_aligned(dst, chunk.data, chunk.len);   // erase-before-write + align
    pos += chunk.len;
    store_resume_marker(pos);
  }
  return verify_full_hash(dst, p->target_hash);
}

재개 마커: 전원 실패 후 pos부터 재시작. 마커는 저널 방식/2섹터 토글.


Manifest(추가 필드 예시)
{{
  "from_version": "1.4.2",
  "from_hash": "base-image-sha256",
  "target_version": "1.4.3",
  "target_hash": "new-image-sha256",
  "delta_size": 183742,
  "block": 65536,
  "apply": {{
    "erase_align": 65536,
    "write_align": 256
  }}
}}

erase_align/write_align은 디바이스별로 다르므로 서버가 타깃별 manifest를 생성.


성능/신뢰성 팁

작은 패치는 압축 이득 < 오버헤드일 수 있음 → 임계값 이상에서만 델타 사용.
대용량 NAND는 ECC/OOB 고려, 블록 불량 테이블(BBT) 유지.
측정 자동화: 네트워크 트래픽, 플래시 쓰기량, 적용시간, 실패율을 CI에 리포팅.


체크리스트

 from_version/hash 불일치 시 전체 이미지 폴백.
 Out-of-place 적용 + 스왑(안전).
 정렬/지우기 단위에 맞춘 청크/쓰기.
 재개 마커/블록 CRC + 전체 해시 재검증.
 Wear-level 정책(순환/분산) 적용.
 성능 임계값 기준으로 델타/풀이미지 선택.


흔한 문제

  
      
          현상
          원인
          대응
      
  
  
      
          적용 중 손상
          정렬 미스, 전원 중단
          정렬 강제, 재개 마커 + 저널링
      
      
          부팅 후 크래시
          베이스 mismatch
          베이스 검증 실패 시 폴백 강제
      
      
          플래시 수명 악화
          임시 영역 남용
          임시 영역 wear-level/크기 조정
      
  
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nlimbo76.github.io/tech-notes/posts/"},{"@type":"ListItem","position":2,"name":"델타 OTA와 스토리지 레이아웃 (분할/정렬/Wear-level) (정리판)","item":"https://nlimbo76.github.io/tech-notes/posts/delta-ota-storage-layout/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"델타 OTA와 스토리지 레이아웃 (분할/정렬/Wear-level) (정리판)","name":"델타 OTA와 스토리지 레이아웃 (분할\/정렬\/Wear-level) (정리판)","description":"개요 네트워크/스토리지 제약이 큰 디바이스에서는 델타 OTA(이전 버전 대비 차분만 전송)가 큰 이점을 줍니다. 하지만 플래시 정렬/지우기 단위, 전원 중단 내성, Wear-level, 베이스 버전 검증 등 레이아웃 제약을 함께 설계해야 합니다.\n핵심 포인트 델타 형식: bsdiff/xdelta/압축 결합(zstd). MCU에선 스트리밍 적용 가능한 간단 포맷 선호. 베이스 버전 고정: from_version과 베이스 해시를 manifest에 명시, 불일치 시 전체 이미지로 폴백. Out-of-place 적용: 같은 슬롯 내 임시 영역 또는 B슬롯에 패치 적용 후 스왑(권장). 정렬/지우기 단위: NOR(4–64KB), NAND(128KB+) 지우기 단위에 맞춰 청크 경계/쓰기 정렬 유지. 검증: 적용 후 전체 해시 재검증 + 블록 CRC. 전원 끊김 시 재개 지점 기록. Wear-level: 자주 바뀌는 메타/로그는 순환 영역 사용, 델타 임시 파일은 균등 분산. 레이아웃 예시 [Boot] [Env] [A: App] [B: App] [DeltaScratch] [Shared(Log/Meta)] DeltaScratch: 패치 적용 중 임시 저장, 지우기 단위 정렬. Shared: 오류 로그/통계, 롤백 후 원인 분석에 활용. 델타 적용 흐름(의사코드) bool apply_delta(const patch_t* p){ if (!base_version_ok(p-\u0026gt;from_ver) || !base_hash_ok(p-\u0026gt;from_hash)) return false; pos = 0; while (next_chunk(\u0026amp;chunk)){ if (!verify_chunk_crc(\u0026amp;chunk)) return fail_resume(pos); write_aligned(dst, chunk.data, chunk.len); // erase-before-write + align pos += chunk.len; store_resume_marker(pos); } return verify_full_hash(dst, p-\u0026gt;target_hash); } 재개 마커: 전원 실패 후 pos부터 재시작. 마커는 저널 방식/2섹터 토글. Manifest(추가 필드 예시) {{ \u0026#34;from_version\u0026#34;: \u0026#34;1.4.2\u0026#34;, \u0026#34;from_hash\u0026#34;: \u0026#34;base-image-sha256\u0026#34;, \u0026#34;target_version\u0026#34;: \u0026#34;1.4.3\u0026#34;, \u0026#34;target_hash\u0026#34;: \u0026#34;new-image-sha256\u0026#34;, \u0026#34;delta_size\u0026#34;: 183742, \u0026#34;block\u0026#34;: 65536, \u0026#34;apply\u0026#34;: {{ \u0026#34;erase_align\u0026#34;: 65536, \u0026#34;write_align\u0026#34;: 256 }} }} erase_align/write_align은 디바이스별로 다르므로 서버가 타깃별 manifest를 생성. 성능/신뢰성 팁 작은 패치는 압축 이득 \u0026lt; 오버헤드일 수 있음 → 임계값 이상에서만 델타 사용. 대용량 NAND는 ECC/OOB 고려, 블록 불량 테이블(BBT) 유지. 측정 자동화: 네트워크 트래픽, 플래시 쓰기량, 적용시간, 실패율을 CI에 리포팅. 체크리스트 from_version/hash 불일치 시 전체 이미지 폴백. Out-of-place 적용 + 스왑(안전). 정렬/지우기 단위에 맞춘 청크/쓰기. 재개 마커/블록 CRC + 전체 해시 재검증. Wear-level 정책(순환/분산) 적용. 성능 임계값 기준으로 델타/풀이미지 선택. 흔한 문제 현상 원인 대응 적용 중 손상 정렬 미스, 전원 중단 정렬 강제, 재개 마커 + 저널링 부팅 후 크래시 베이스 mismatch 베이스 검증 실패 시 폴백 강제 플래시 수명 악화 임시 영역 남용 임시 영역 wear-level/크기 조정 ","keywords":["OTA","델타업데이트","스토리지","Wear-level","링커/레이아웃"],"articleBody":"개요 네트워크/스토리지 제약이 큰 디바이스에서는 델타 OTA(이전 버전 대비 차분만 전송)가 큰 이점을 줍니다. 하지만 플래시 정렬/지우기 단위, 전원 중단 내성, Wear-level, 베이스 버전 검증 등 레이아웃 제약을 함께 설계해야 합니다.\n핵심 포인트 델타 형식: bsdiff/xdelta/압축 결합(zstd). MCU에선 스트리밍 적용 가능한 간단 포맷 선호. 베이스 버전 고정: from_version과 베이스 해시를 manifest에 명시, 불일치 시 전체 이미지로 폴백. Out-of-place 적용: 같은 슬롯 내 임시 영역 또는 B슬롯에 패치 적용 후 스왑(권장). 정렬/지우기 단위: NOR(4–64KB), NAND(128KB+) 지우기 단위에 맞춰 청크 경계/쓰기 정렬 유지. 검증: 적용 후 전체 해시 재검증 + 블록 CRC. 전원 끊김 시 재개 지점 기록. Wear-level: 자주 바뀌는 메타/로그는 순환 영역 사용, 델타 임시 파일은 균등 분산. 레이아웃 예시 [Boot] [Env] [A: App] [B: App] [DeltaScratch] [Shared(Log/Meta)] DeltaScratch: 패치 적용 중 임시 저장, 지우기 단위 정렬. Shared: 오류 로그/통계, 롤백 후 원인 분석에 활용. 델타 적용 흐름(의사코드) bool apply_delta(const patch_t* p){ if (!base_version_ok(p-\u003efrom_ver) || !base_hash_ok(p-\u003efrom_hash)) return false; pos = 0; while (next_chunk(\u0026chunk)){ if (!verify_chunk_crc(\u0026chunk)) return fail_resume(pos); write_aligned(dst, chunk.data, chunk.len); // erase-before-write + align pos += chunk.len; store_resume_marker(pos); } return verify_full_hash(dst, p-\u003etarget_hash); } 재개 마커: 전원 실패 후 pos부터 재시작. 마커는 저널 방식/2섹터 토글. Manifest(추가 필드 예시) {{ \"from_version\": \"1.4.2\", \"from_hash\": \"base-image-sha256\", \"target_version\": \"1.4.3\", \"target_hash\": \"new-image-sha256\", \"delta_size\": 183742, \"block\": 65536, \"apply\": {{ \"erase_align\": 65536, \"write_align\": 256 }} }} erase_align/write_align은 디바이스별로 다르므로 서버가 타깃별 manifest를 생성. 성능/신뢰성 팁 작은 패치는 압축 이득 \u003c 오버헤드일 수 있음 → 임계값 이상에서만 델타 사용. 대용량 NAND는 ECC/OOB 고려, 블록 불량 테이블(BBT) 유지. 측정 자동화: 네트워크 트래픽, 플래시 쓰기량, 적용시간, 실패율을 CI에 리포팅. 체크리스트 from_version/hash 불일치 시 전체 이미지 폴백. Out-of-place 적용 + 스왑(안전). 정렬/지우기 단위에 맞춘 청크/쓰기. 재개 마커/블록 CRC + 전체 해시 재검증. Wear-level 정책(순환/분산) 적용. 성능 임계값 기준으로 델타/풀이미지 선택. 흔한 문제 현상 원인 대응 적용 중 손상 정렬 미스, 전원 중단 정렬 강제, 재개 마커 + 저널링 부팅 후 크래시 베이스 mismatch 베이스 검증 실패 시 폴백 강제 플래시 수명 악화 임시 영역 남용 임시 영역 wear-level/크기 조정 ","wordCount":"317","inLanguage":"en","datePublished":"2025-08-24T00:00:00Z","dateModified":"2025-08-24T00:00:00Z","author":{"@type":"Person","name":"gBear"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nlimbo76.github.io/tech-notes/posts/delta-ota-storage-layout/"},"publisher":{"@type":"Organization","name":"gBear's Tech Notes","logo":{"@type":"ImageObject","url":"https://nlimbo76.github.io/tech-notes/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nlimbo76.github.io/tech-notes/ accesskey=h title="gBear's Tech Notes (Alt + H)">gBear's Tech Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nlimbo76.github.io/tech-notes/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://nlimbo76.github.io/tech-notes/series/ title=Series><span>Series</span></a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://nlimbo76.github.io/tech-notes/>Home</a>&nbsp;»&nbsp;<a href=https://nlimbo76.github.io/tech-notes/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">델타 OTA와 스토리지 레이아웃 (분할/정렬/Wear-level) (정리판)</h1><div class=post-meta><span title='2025-08-24 00:00:00 +0000 UTC'>2025-08-24</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;gBear</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b0%9c%ec%9a%94 aria-label=개요>개요</a></li><li><a href=#%ed%95%b5%ec%8b%ac-%ed%8f%ac%ec%9d%b8%ed%8a%b8 aria-label="핵심 포인트">핵심 포인트</a></li><li><a href=#%eb%a0%88%ec%9d%b4%ec%95%84%ec%9b%83-%ec%98%88%ec%8b%9c aria-label="레이아웃 예시">레이아웃 예시</a></li><li><a href=#%eb%8d%b8%ed%83%80-%ec%a0%81%ec%9a%a9-%ed%9d%90%eb%a6%84%ec%9d%98%ec%82%ac%ec%bd%94%eb%93%9c aria-label="델타 적용 흐름(의사코드)">델타 적용 흐름(의사코드)</a></li><li><a href=#manifest%ec%b6%94%ea%b0%80-%ed%95%84%eb%93%9c-%ec%98%88%ec%8b%9c aria-label="Manifest(추가 필드 예시)">Manifest(추가 필드 예시)</a></li><li><a href=#%ec%84%b1%eb%8a%a5%ec%8b%a0%eb%a2%b0%ec%84%b1-%ed%8c%81 aria-label="성능/신뢰성 팁">성능/신뢰성 팁</a></li><li><a href=#%ec%b2%b4%ed%81%ac%eb%a6%ac%ec%8a%a4%ed%8a%b8 aria-label=체크리스트>체크리스트</a></li><li><a href=#%ed%9d%94%ed%95%9c-%eb%ac%b8%ec%a0%9c aria-label="흔한 문제">흔한 문제</a></li></ul></div></details></div><div class=post-content><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><p>네트워크/스토리지 제약이 큰 디바이스에서는 <strong>델타 OTA</strong>(이전 버전 대비 차분만 전송)가 큰 이점을 줍니다. 하지만 플래시 정렬/지우기 단위, 전원 중단 내성, Wear-level, 베이스 버전 검증 등 <strong>레이아웃 제약</strong>을 함께 설계해야 합니다.</p><hr><h2 id=핵심-포인트>핵심 포인트<a hidden class=anchor aria-hidden=true href=#핵심-포인트>#</a></h2><ul><li><strong>델타 형식</strong>: bsdiff/xdelta/압축 결합(zstd). MCU에선 <strong>스트리밍 적용</strong> 가능한 간단 포맷 선호.</li><li><strong>베이스 버전 고정</strong>: <code>from_version</code>과 <strong>베이스 해시</strong>를 manifest에 명시, 불일치 시 전체 이미지로 폴백.</li><li><strong>Out-of-place 적용</strong>: 같은 슬롯 내 <strong>임시 영역</strong> 또는 B슬롯에 패치 적용 후 스왑(권장).</li><li><strong>정렬/지우기 단위</strong>: NOR(4–64KB), NAND(128KB+) 지우기 단위에 맞춰 <strong>청크 경계/쓰기 정렬</strong> 유지.</li><li><strong>검증</strong>: 적용 후 전체 해시 재검증 + 블록 CRC. <strong>전원 끊김</strong> 시 재개 지점 기록.</li><li><strong>Wear-level</strong>: 자주 바뀌는 메타/로그는 순환 영역 사용, 델타 임시 파일은 균등 분산.</li></ul><hr><h2 id=레이아웃-예시>레이아웃 예시<a hidden class=anchor aria-hidden=true href=#레이아웃-예시>#</a></h2><pre tabindex=0><code>[Boot] [Env] [A: App] [B: App] [DeltaScratch] [Shared(Log/Meta)]
</code></pre><ul><li><code>DeltaScratch</code>: 패치 적용 중 임시 저장, 지우기 단위 정렬.</li><li><code>Shared</code>: 오류 로그/통계, 롤백 후 원인 분석에 활용.</li></ul><hr><h2 id=델타-적용-흐름의사코드>델타 적용 흐름(의사코드)<a hidden class=anchor aria-hidden=true href=#델타-적용-흐름의사코드>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>apply_delta</span><span class=p>(</span><span class=k>const</span> <span class=kt>patch_t</span><span class=o>*</span> <span class=n>p</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>base_version_ok</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>from_ver</span><span class=p>)</span> <span class=o>||</span> <span class=o>!</span><span class=nf>base_hash_ok</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>from_hash</span><span class=p>))</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>pos</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nf>next_chunk</span><span class=p>(</span><span class=o>&amp;</span><span class=n>chunk</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>verify_chunk_crc</span><span class=p>(</span><span class=o>&amp;</span><span class=n>chunk</span><span class=p>))</span> <span class=k>return</span> <span class=nf>fail_resume</span><span class=p>(</span><span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>write_aligned</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span> <span class=n>chunk</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> <span class=n>chunk</span><span class=p>.</span><span class=n>len</span><span class=p>);</span>   <span class=c1>// erase-before-write + align
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pos</span> <span class=o>+=</span> <span class=n>chunk</span><span class=p>.</span><span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>store_resume_marker</span><span class=p>(</span><span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>verify_full_hash</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>target_hash</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>재개 마커</strong>: 전원 실패 후 <code>pos</code>부터 재시작. 마커는 저널 방식/2섹터 토글.</li></ul><hr><h2 id=manifest추가-필드-예시>Manifest(추가 필드 예시)<a hidden class=anchor aria-hidden=true href=#manifest추가-필드-예시>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span><span class=err>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;from_version&#34;</span><span class=p>:</span> <span class=s2>&#34;1.4.2&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;from_hash&#34;</span><span class=p>:</span> <span class=s2>&#34;base-image-sha256&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;target_version&#34;</span><span class=p>:</span> <span class=s2>&#34;1.4.3&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;target_hash&#34;</span><span class=p>:</span> <span class=s2>&#34;new-image-sha256&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;delta_size&#34;</span><span class=p>:</span> <span class=mi>183742</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;block&#34;</span><span class=p>:</span> <span class=mi>65536</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;apply&#34;</span><span class=p>:</span> <span class=p>{</span><span class=err>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;erase_align&#34;</span><span class=p>:</span> <span class=mi>65536</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;write_align&#34;</span><span class=p>:</span> <span class=mi>256</span>
</span></span><span class=line><span class=cl>  <span class=p>}}</span>
</span></span><span class=line><span class=cl><span class=err>}}</span>
</span></span></code></pre></div><ul><li><code>erase_align</code>/<code>write_align</code>은 디바이스별로 다르므로 서버가 <strong>타깃별 manifest</strong>를 생성.</li></ul><hr><h2 id=성능신뢰성-팁>성능/신뢰성 팁<a hidden class=anchor aria-hidden=true href=#성능신뢰성-팁>#</a></h2><ul><li>작은 패치는 <strong>압축 이득 &lt; 오버헤드</strong>일 수 있음 → 임계값 이상에서만 델타 사용.</li><li>대용량 NAND는 <strong>ECC/OOB</strong> 고려, 블록 불량 테이블(BBT) 유지.</li><li><strong>측정 자동화</strong>: 네트워크 트래픽, 플래시 쓰기량, 적용시간, 실패율을 CI에 리포팅.</li></ul><hr><h2 id=체크리스트>체크리스트<a hidden class=anchor aria-hidden=true href=#체크리스트>#</a></h2><ul><li><input disabled type=checkbox> <code>from_version/hash</code> 불일치 시 전체 이미지 폴백.</li><li><input disabled type=checkbox> Out-of-place 적용 + 스왑(안전).</li><li><input disabled type=checkbox> 정렬/지우기 단위에 맞춘 청크/쓰기.</li><li><input disabled type=checkbox> 재개 마커/블록 CRC + 전체 해시 재검증.</li><li><input disabled type=checkbox> Wear-level 정책(순환/분산) 적용.</li><li><input disabled type=checkbox> 성능 임계값 기준으로 델타/풀이미지 선택.</li></ul><hr><h2 id=흔한-문제>흔한 문제<a hidden class=anchor aria-hidden=true href=#흔한-문제>#</a></h2><table><thead><tr><th>현상</th><th>원인</th><th>대응</th></tr></thead><tbody><tr><td>적용 중 손상</td><td>정렬 미스, 전원 중단</td><td>정렬 강제, 재개 마커 + 저널링</td></tr><tr><td>부팅 후 크래시</td><td>베이스 mismatch</td><td>베이스 검증 실패 시 폴백 강제</td></tr><tr><td>플래시 수명 악화</td><td>임시 영역 남용</td><td>임시 영역 wear-level/크기 조정</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://nlimbo76.github.io/tech-notes/tags/ota/>OTA</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/%EB%8D%B8%ED%83%80%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/>델타업데이트</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80/>스토리지</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/wear-level/>Wear-Level</a></li><li><a href=https://nlimbo76.github.io/tech-notes/tags/%EB%A7%81%EC%BB%A4/%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/>링커/레이아웃</a></li></ul><nav class=paginav><a class=prev href=https://nlimbo76.github.io/tech-notes/posts/ota-signed-pipeline/><span class=title>« Prev</span><br><span>OTA 업데이트 파이프라인과 이미지 서명 (정리판)</span>
</a><a class=next href=https://nlimbo76.github.io/tech-notes/posts/bootloader-ab-rollback/><span class=title>Next »</span><br><span>부트로더 A/B + 안전 롤백 설계 (정리판)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://nlimbo76.github.io/tech-notes/>gBear's Tech Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>